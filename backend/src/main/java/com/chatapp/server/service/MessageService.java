package com.chatapp.server.service;// MessageService.java (Complete Version)import com.chatapp.server.Models.Conversation;import com.chatapp.server.Models.Message;import com.chatapp.server.Models.User;import com.chatapp.server.repository.MessageRepository;import lombok.RequiredArgsConstructor;import org.springframework.stereotype.Service;import java.util.List;import java.util.Optional;@Service@RequiredArgsConstructorpublic class MessageService {    private final MessageRepository messageRepository;    private final ConversationService conversationService;    private final UserService userService;    // Additional helper method in MessageService    private void validateMessageRequest(Long conversationId, Long senderId, String content) {        if (conversationId == null || conversationId <= 0) {            throw new RuntimeException("Invalid conversation ID: " + conversationId);        }        if (senderId == null || senderId <= 0) {            throw new RuntimeException("Invalid sender ID: " + senderId);        }        if (content == null || content.trim().isEmpty()) {            throw new RuntimeException("Message content cannot be empty");        }    }    public Message sendMessage(Long conversationId, Long senderId, Long receiverId, String content) {        // Validate basic request parameters        validateMessageRequest(conversationId, senderId, content);        // Get conversation and sender        var conversation = conversationService.findById(conversationId)                .orElseThrow(() -> new RuntimeException("Conversation not found with ID: " + conversationId));        var sender = userService.findById(senderId)                .orElseThrow(() -> new RuntimeException("Sender not found with ID: " + senderId));        // Resolve receiver        var receiver = resolveReceiver(receiverId, conversation, sender);        // Create and save message        Message message = new Message();        message.setConversation(conversation);        message.setSender(sender);        message.setReceiver(receiver);        message.setContent(content);        return messageRepository.save(message);    }    private User resolveReceiver(Long receiverId, Conversation conversation, User sender) {        // If receiverId is provided and valid, use it        if (receiverId != null && receiverId > 0) {            return userService.findById(receiverId)                    .orElseThrow(() -> new RuntimeException("Receiver not found with ID: " + receiverId));        }        // Otherwise, determine receiver based on conversation and sender        if (conversation.getAgent() != null && conversation.getCustomer() != null) {            // If conversation has both agent and customer, receiver is the other party            if (sender.getId().equals(conversation.getCustomer().getUser().getId())) {                // Sender is customer, receiver should be agent                return conversation.getAgent().getUser();            } else if (conversation.getAgent().getUser() != null &&                    sender.getId().equals(conversation.getAgent().getUser().getId())) {                // Sender is agent, receiver should be customer                return conversation.getCustomer().getUser();            }        }        // If we can't determine receiver, throw meaningful error        throw new RuntimeException("Cannot determine receiver for conversation. " +                "Conversation must have both customer and agent assigned, or provide explicit receiverId.");    }    public List<Message> getConversationMessages(Long conversationId) {        return messageRepository.findByConversationIdOrderByCreatedAtAsc(conversationId);    }}